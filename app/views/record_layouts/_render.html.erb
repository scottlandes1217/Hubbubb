<%# Renders saved layout for a record by injecting values into placeholders %>
<%# Locals: layout:, record:, table_type: %>

<% html = layout.html.html_safe %>
<% css = layout.css.html_safe %>
<style><%= css %></style>
<style>
  /* Runtime overrides: disable builder-only behaviors on real pages */
  .record-layout-render .record-field-placeholder,
  .record-layout-render .record-partial-placeholder {
    pointer-events: auto !important;
    cursor: default !important;
  }
  .record-layout-render .record-field-placeholder *,
  .record-layout-render .record-partial-placeholder * {
    pointer-events: auto !important;
  }
  .record-layout-render .record-field-placeholder:hover,
  .record-layout-render .record-partial-placeholder:hover {
    outline: none !important;
  }
  .record-layout-render .edit-button,
  .record-layout-render .name-field-header .edit-button {
    pointer-events: auto !important;
    cursor: pointer;
  }
  /* Remove section borders on rendered pages */
  .record-layout-render .pf-section {
    border: none !important;
  }
  .record-layout-render .pf-section-column {
    border: none !important;
    background: transparent !important;
  }
</style>

<div class="record-layout-render">
  <%= html %>
</div>

<%# Build values hash exposed to client for simple placeholder fill %>
<%
  values = {}
  field_meta = record_layout_field_meta_map(@organization, table_type, @custom_object&.id)
  options_map = record_layout_options_map(@organization, table_type)
  case table_type
  when 'Pet'
    values = record.attributes.slice('name', 'breed', 'age', 'species', 'description', 'adopted')
  when 'CustomObject'
    values = record.field_values.merge('name' => record.name, 'external_id' => record.external_id)
  else
    values = {}
  end
%>
<script type="application/json" id="record-values-json"><%= raw values.to_json %></script>
<script>
  (function() {
    try {
      const valuesEl = document.getElementById('record-values-json');
      const values = valuesEl ? JSON.parse(valuesEl.textContent) : {};
      document.querySelectorAll('[field-api-name]').forEach(function(el){
        const api = el.getAttribute('field-api-name');
        const label = el.getAttribute('field-label') || api;
        let ftype = el.getAttribute('field-type') || 'text';
        // Override with server meta when available
        <%# Embed meta map as JSON %>
        const metaMap = <%= raw field_meta.to_json %>;
        if (metaMap[api] && metaMap[api]['type']) {
          ftype = metaMap[api]['type'];
        }
        // Always set options at runtime from server options map when available
        const serverOpts = (function(){ try { return (<%= raw options_map.to_json %>)[api] || []; } catch(e) { return []; } })();
        if (serverOpts.length > 0) {
          el.setAttribute('data-options', serverOpts.join('|'));
          if (['picklist','multipicklist'].indexOf(ftype) === -1) {
            // If options present but type not picklist, coerce to picklist (or multipicklist for known multi keys)
            if (['breed','color','flags'].indexOf(api) !== -1) ftype = 'multipicklist'; else ftype = 'picklist';
          }
        }
        // Explicitly treat certain keys as their expected types
        if (api === 'breed') ftype = 'multipicklist';
        const val = values && Object.prototype.hasOwnProperty.call(values, api) ? values[api] : '';
        const safeVal = (val == null ? '' : String(val));
        el.classList.add('field-container');
        // Generate a unique instance ID for this field instance
        const instanceId = 'field-instance-' + api + '-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        let inputHtml = '';
        if (ftype === 'textarea') {
          inputHtml = '<textarea class="edit-input form-control" data-field="' + api + '" data-instance-id="' + instanceId + '" data-edit-field-target="input" style="display:none;">' + safeVal.replace(/</g,'&lt;').replace(/>/g,'&gt;') + '</textarea>';
        } else if (ftype === 'checkbox') {
          const checked = (safeVal === 'true' || safeVal === '1') ? 'checked' : '';
          inputHtml = '<div class="form-check" style="display:none;"><input type="checkbox" class="form-check-input edit-input" data-field="' + api + '" data-instance-id="' + instanceId + '" data-edit-field-target="input" ' + checked + ' /></div>';
        } else if (ftype === 'date') {
          inputHtml = '<input type="date" class="edit-input form-control" data-field="' + api + '" data-instance-id="' + instanceId + '" data-edit-field-target="input" value="' + safeVal + '" style="display:none;" />';
        } else if (ftype === 'picklist') {
          const opts = (el.getAttribute('data-options') || '').split('|').filter(Boolean);
          if (opts.length === 0) {
            opts.push('None');
          }
          inputHtml = '<select class="edit-input form-select" data-field="' + api + '" data-instance-id="' + instanceId + '" data-edit-field-target="input" style="display:none;">' + opts.map(function(o){ return '<option value="' + o.replace(/"/g,'&quot;') + '" ' + (o===safeVal?'selected':'') + '>' + o + '</option>'; }).join('') + '</select>';
        } else if (ftype === 'multipicklist') {
          const opts = (el.getAttribute('data-options') || '').split('|').filter(Boolean);
          if (opts.length === 0) {
            opts.push('None');
          }
          const selected = Array.isArray(val) ? val : String(safeVal).split(',').map(function(s){ return s.trim(); });
          inputHtml = '<select multiple class="edit-input form-select" data-field="' + api + '" data-instance-id="' + instanceId + '" data-edit-field-target="input" style="display:none;">' + opts.map(function(o){ return '<option value="' + o.replace(/"/g,'&quot;') + '" ' + (selected.includes(o)?'selected':'') + '>' + o + '</option>'; }).join('') + '</select>';
        } else {
          // Remove mt-2 class that adds top margin and pushes input to new line
          inputHtml = '<input type="text" class="edit-input form-control" data-field="' + api + '" data-instance-id="' + instanceId + '" data-edit-field-target="input" value="' + safeVal.replace(/"/g, '&quot;') + '" style="display:none;" />';
        }
        el.innerHTML =
          '<div class="record-field-display">' +
            '<strong class="field-label">' + (label || '') + ':</strong> ' +
            '<span class="field-value" data-edit-field-target="value" data-field="' + api + '" data-instance-id="' + instanceId + '">' + safeVal + '</span>' +
            '<button class="edit-button" data-field="' + api + '" data-instance-id="' + instanceId + '" data-edit-field-target="editButton" data-action="click->edit-field#edit" title="Edit ' + (label || api) + '" aria-label="Edit ' + (label || api) + '"><i class="fas fa-pencil-alt"></i></button>' +
            inputHtml +
          '</div>';
      });

      // Replace partial placeholders with known server-rendered partials
      var partials = {};
      <% if table_type == 'Pet' %>
        <% begin %>
          <% partial_html = render('pets/pet_header', pet: record, with_id: false) %>
          <% if partial_html.present? %>
            partials['pets/pet_header'] = <%= raw(partial_html.to_json) %>;
            console.log('[Runtime] Rendered pet header successfully, length:', partials['pets/pet_header'] ? partials['pets/pet_header'].length : 0);
          <% else %>
            console.error('[Runtime] Pet header render returned empty or nil');
            partials['pets/pet_header'] = '';
          <% end %>
        <% rescue => e %>
          console.error('[Runtime] Error rendering pet header:', <%= raw(e.message.to_json) %>);
          partials['pets/pet_header'] = '';
        <% end %>
      <% end %>
      console.log('[Runtime] Partials object:', partials);
      console.log('[Runtime] Partials keys:', Object.keys(partials));
      console.log('[Runtime] Partial value for pets/pet_header:', partials['pets/pet_header']);
      console.log('[Runtime] Partial value type:', typeof partials['pets/pet_header']);
      console.log('[Runtime] Looking for elements with [partial-name] attribute');
      document.querySelectorAll('[partial-name]').forEach(function(el){
        var name = el.getAttribute('partial-name');
        var keys = Object.keys(partials);
        var firstKey = keys[0];
        console.log('[Runtime] Found partial element', { 
          name: name, 
          nameType: typeof name,
          nameLength: name ? name.length : 0,
          nameCharCodes: name ? Array.from(name).map(c => c.charCodeAt(0)) : [],
          hasPartial: !!partials[name], 
          partialsKeys: keys,
          firstKey: firstKey,
          firstKeyCharCodes: firstKey ? Array.from(firstKey).map(c => c.charCodeAt(0)) : [],
          keysMatch: name === firstKey,
          element: el,
          elementHTML: el.outerHTML.substring(0, 200)
        });
        if (name && partials[name]) {
          // The partials[name] is already properly escaped by the j() helper
          // Create a temporary element to parse the HTML string
          const temp = document.createElement('div');
          // Set innerHTML - this will parse the HTML string correctly
          temp.innerHTML = partials[name];
          const fresh = temp.firstElementChild;
          if (fresh && el.parentNode) {
            // Replace the entire element to remove placeholder classes
            console.log('[Runtime] Replacing partial element with content', fresh);
            el.parentNode.replaceChild(fresh, el);
          } else {
            // Fallback: if no firstElementChild (shouldn't happen), try setting innerHTML directly
            console.log('[Runtime] Using fallback: setting innerHTML directly');
            el.innerHTML = partials[name];
            // Remove placeholder classes that might hide content
            el.classList.remove('record-partial-placeholder', 'pf-interactive', 'border', 'rounded', 'p-2', 'mb-2', 'bg-light');
          }
        } else {
          console.warn('[Runtime] Partial not found or name missing', { name, partialsKeys: Object.keys(partials) });
        }
      });
      // Fallback: If saved layout lacks partial-name attribute, aggressively replace any header snapshot
      // with the live-rendered header to avoid stale text and ensure photo is always shown.
      // BUT: Skip headers that are inside [partial-name] elements (already replaced correctly)
      try {
        if (partials['pets/pet_header']) {
          const candidates = new Set();
          // Find all pet-header elements that haven't been replaced yet
          document.querySelectorAll('.pet-header, [id^="pet_header_"]').forEach(n => {
            // Skip if this node or any ancestor has [partial-name] attribute (already handled)
            let check = n;
            let skip = false;
            while (check && check !== document.body) {
              if (check.hasAttribute && check.hasAttribute('partial-name')) {
                skip = true;
                break;
              }
              check = check.parentElement;
            }
            if (!skip) candidates.add(n);
          });
          // Also find name-field-header elements that might be part of a pet header
          document.querySelectorAll('.name-field-header').forEach(n => {
            // Skip if inside a [partial-name] element
            let check = n;
            let skip = false;
            while (check && check !== document.body) {
              if (check.hasAttribute && check.hasAttribute('partial-name')) {
                skip = true;
                break;
              }
              check = check.parentElement;
            }
            if (!skip) {
              const header = n.closest('.pet-header');
              if (header) candidates.add(header);
            }
          });
          // Replace all candidates with fresh rendered header (includes photo)
          candidates.forEach(function(node){
            if (!node || !node.parentNode) return;
            const temp = document.createElement('div');
            temp.innerHTML = partials['pets/pet_header'];
            const fresh = temp.firstElementChild;
            if (fresh) {
              node.parentNode.replaceChild(fresh, node);
            }
          });
        }
      } catch(e) {
        console.warn('Error replacing pet header:', e);
      }

      // Strip builder-only wrappers if any leaked into runtime HTML (initial + future mutations)
      (function(){
        const scrub = () => {
          try {
            document.querySelectorAll('.partial-content-wrapper').forEach(function(node){
              // Defensive: remove volatile id to avoid churn in observers/analytics
              try { node.removeAttribute('id'); } catch(_) {}
              const parent = node.parentNode;
              if (!parent) return;
              while (node.firstChild) parent.insertBefore(node.firstChild, node);
              parent.removeChild(node);
            });
          } catch(_) {}
        };
        // Run now and also watch for future insertions briefly
        scrub();
        try {
          const container = document.querySelector('.record-layout-render') || document;
          const mo = new MutationObserver(() => scrub());
          mo.observe(container, { childList: true, subtree: true });
          setTimeout(() => { try { mo.disconnect(); } catch(_) {} }, 3000);
        } catch(_) {}
      })();

      // Ensure header name text matches server value regardless of how the layout was saved
      try {
        const nameVal = (values && typeof values.name === 'string') ? values.name : '';
        if (nameVal) {
          const nameTargets = [
            '.name-field-header [data-field="name"][data-edit-field-target="value"]',
            '.pet-header [data-field="name"][data-edit-field-target="value"]',
            '[field-api-name="name"] .rf-value'
          ];
          document.querySelectorAll(nameTargets.join(',')).forEach(function(el){
            try { el.textContent = nameVal; } catch(_) {}
          });
        }
      } catch(_) {}
    } catch(e) { console.warn('record values fill error', e); }
  })();
</script>

<% if layout.js.present? %>
  <script><%= layout.js.html_safe %></script>
<% end %>


